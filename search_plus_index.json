{"./":{"url":"./","title":"引言","keywords":"","body":"把工作和学习中一些技巧和方法整理记录下来。 GitHub Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/README.html\"});gitalk.render(\"gitalk-container\"); "},"笔记/":{"url":"笔记/","title":"笔记12","keywords":"","body":"笔记 把一些工作中遇到的问题以及解决办法记录下来。 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/README.html\"});gitalk.render(\"gitalk-container\"); "},"笔记/GitBook安装使用与部署.html":{"url":"笔记/GitBook安装使用与部署.html","title":"GitBook安装使用与部署","keywords":"","body":"安装方法 安装命令 brew cask install gitbook 安装遇到问题：TypeError: cb.apply is not a function. 原因: node版本不对，本地是14.0.0需要使用12.16.3版本. 解决方法：安装nvm管理本地的多node版本 使用方法 在当前目录用下面命令跑起来，可以预览，而且修改md文件后预览会实时变化。 gitbook serve 编译生成一个_book文件夹。 gitbook build 部署到GitHub 首先在你的github建立一个Public的xxx.github.io仓库（这个域名的xxx你自己记得修改，后面的格式固定），这个名字就是你网页的域名。 把这个仓库clone到本地。 git clone https://github.com/xxx/xxx.github.io.git 然后把上面使用方法生成的_book文件夹下面的所有文件拷贝到本地的xxx.github.io目录下，然后push到云端。 git add . git commit -m \"xxx\" git push 完成后就可以打开xxx.github.io了。 基于GitHub Issues的GitBook评论插件gitalk 其他简单插件可以参考推荐12个实用的gitbook插件这篇文章。 这里重点介绍一下评论插件gitalk。还有一个评论插件叫disqus不过不推荐使用。 gitalk的使用不用去网上搜，网上教程说的每个文件都要加代码的问题官方已经支持了，按官方介绍用就可以了。 介绍中的参数clientID和clientSecret可以通过点击在线申请在GitHub申请一个授权应用得到。 部署到自己的云服务器 下面的远程服务器都是指腾讯云Debian系统，当然其他云也是没问题的。 安装docker，然后部署nginx 在远程服务器上先随便启动一个容器，主要是用来生成默认的配置文件。 docker run -d -p 80:80 --name mynginx nginx 然后创建一个本地文件夹把默认配置copy一份，然后关闭这个容器并删除。 mkdir /web cd /web docker cp mynginx:/etc/nginx/conf.d . docker stop mynginx docker rm mynginx 可以使用vim编辑这个配置文件（这一步可以不做）。 vim conf.d/default.conf 可以看到有一个/usr/share/nginx/html，表示资源地址，不过这个资源地址是容器的修改了也没用，我们启动的时候把本地目录映射到这个地址就可以了，所以这里不需要修改，如果深入研究这个配置文件，可以做到很多事。 然后本地电脑把要部署的资源上传到远程服务器。 scp -r _book root@ip:/web/book 最后在远程服务器上启动容器并加上映射。这个80:80前面这个80是服务器的端口，后面这个80是容器的端口。映射-v可以加很多个，一般把conf里面需要用到的加上就可以了，我们这里把配置文件和资源路径映射一下就好了。 docker run -d -p 80:80 --name web -v /web/book:/usr/share/nginx/html -v /web/conf.d:/etc/nginx/conf.d nginx 这个时候你就可以直接在浏览器输入你的ip地址浏览这个网页了。 scp提示权限被拒绝的解决办法 Linux的远程传输文件scp出现Permission denied (publickey).lost connection问题解决方法。 首先去~/.ssh目录下看是否已经有密匙。如果没有可以通过下面命令生成一份。.pub结尾的是公匙。 cd ~/.ssh ssh-keygen -t rsa 将当前主机上的id_rsa.pub文件拷贝到远程Linux主机的root用户目录下的.ssh目录下，并且改名为authorized_keys 。若已经有该文件可以把内容追加在后面，要配对多个机器就在后面追加就行了。 这样本地密匙跟远程主机密匙就能对上了，后续scp命令就不需要带鉴权信息了。 问题? 把多个web服务部署到同一个机器上，使用不同的路径访问。 目前尝试了编辑配置文件conf.d/default.conf，但貌似没效果，后续再深入研究一下。目前暂时启动了两个docker指定不同端口来解决这个问题，不过这样就只能这样访问ip:81，不优雅。 如何把多个web服务部署到同一个服务器并使用不同的子域名访问。 参考文章 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/GitBook安装使用与部署.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/GitBook安装使用与部署.html\"});gitalk.render(\"gitalk-container\"); "},"笔记/QuickLook.html":{"url":"笔记/QuickLook.html","title":"QuickLook","keywords":"","body":"3. QuickLook 用后缀名识别的文档类型，无法识别.doc，要用.docx才行。某些代码导出的文档会打不开。 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/QuickLook.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/QuickLook.html\"});gitalk.render(\"gitalk-container\"); "},"笔记/Flutter字体问题.html":{"url":"笔记/Flutter字体问题.html","title":"Flutter字体问题","keywords":"","body":"3. 在flutter里面iOS14英文字体宽度被压缩的问题 iOS和flutter默认字体都是这个SFUI，跟我们说的苹果方体还有一些区别，SF是San Francisco的缩写，是苹方字体的英文部分，中文部分叫PingFang。 但是，两者之间是有差距的。比如对数字的显示，PingFang显示的数字与前后汉字更加紧凑，但是SFUI与前后汉字之间会有一定间隔。 参考issues Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/Flutter字体问题.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/Flutter字体问题.html\"});gitalk.render(\"gitalk-container\"); "},"笔记/scp命令问题.html":{"url":"笔记/scp命令问题.html","title":"scp命令问题","keywords":"","body":"scp命令问题 Linux的远程传输文件scp出现Permission denied (publickey).lost connection问题解决方法。 首先去~/.ssh目录下看是否已经有密匙。如果没有可以通过下面命令生成一份。.pub结尾的是公匙。 cd ~/.ssh ssh-keygen -t rsa 将当前主机上的id_rsa.pub文件拷贝到远程Linux主机的root用户目录下的.ssh目录下，并且改名为authorized_keys 。若已经有该文件可以把内容追加在后面。 这样本地密匙跟远程主机密匙就能对上了，后续scp命令就不需要带鉴权信息了。 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/scp命令问题.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/笔记/scp命令问题.html\"});gitalk.render(\"gitalk-container\"); "},"flutter/":{"url":"flutter/","title":"Flutter","keywords":"","body":"Flutter Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/flutter/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/flutter/README.html\"});gitalk.render(\"gitalk-container\"); "},"flutter/组件解析之Container.html":{"url":"flutter/组件解析之Container.html","title":"组件解析之Container","keywords":"","body":"Flutter组件解析之Container Flutter使用声明式来写UI，跟SwiftUI类似，非常先进。但是与HTML或以前的iOS布局方式差异相当大，这里主要通过介绍万金油组件Container来熟悉这种写法。 一、源码解析 Container实现了很多功能，很多时候有多种需要的时候一个Container就可以搞定。 我们来看看Container的创建源码，每个参数其实都是嵌套了一层小组件，这里把相应的小组件写在后面注释里面了。 Container({ Key key, this.alignment, // Align this.padding, // Padding this.color, // ColoredBox this.decoration, // DecoratedBox this.foregroundDecoration, // DecoratedBox double width, // ConstrainedBox double height, // ConstrainedBox BoxConstraints constraints, // ConstrainedBox this.margin, // Padding this.transform, // Transform this.child, this.clipBehavior = Clip.none, // ClipPath }) 可以点进去看build方法，这里列出部分代码 Widget current = child; ... final EdgeInsetsGeometry effectivePadding = _paddingIncludingDecoration; if (effectivePadding != null) current = Padding(padding: effectivePadding, child: current); if (color != null) current = ColoredBox(color: color, child: current); if (constraints != null) current = ConstrainedBox(constraints: constraints, child: current); if (margin != null) current = Padding(padding: margin, child: current); 比如 Padding(padding: padding, child: ColoredBox(color: color, child: child)) 用Container表示就是下面这样的 Container(color: color, padding: padding, child: child) 不止是Container，还有很多其他组件其实也都是做了一些嵌套而已，这也是声明式UI的一大特色。在Flutter中，Container组件也正是组合优先于继承的实例。 二、属性介绍 1、alignment 对齐方向 需要注意的是Container默认大小是随子组件的，如果设置了这个alignment参数后Container会变成大小会跟随父组件。 2、width、height、constraints 这三个属性会合成一个约束通过ConstrainedBox嵌套。 它们同时出现的时候width、height优先。 3、padding和margin 这两个比较容易用混，我们通过下面一个例子来理解 源码如下 Center( child: Container( color: Colors.black, child: Container( color: Colors.red, margin: EdgeInsets.all(20), padding: EdgeInsets.all(10), child: Container(color: Colors.yellow, height: 10, width: 10), ), ), ) 可以看到红色部分就是padding，在child的外面扩充。 黑色部分就是margin产生的，可以理解为是我虽然只有红色这么大，但是上层你必须给我黑色这么大的空间。 其实build里面的源码嵌套顺序也可以看出来，先设置padding，然后再设置背景颜色和装饰这些，最后再设置margin，相当于最后再在外面套了一个空框。 4、color和 decoration 都是设置背景，color和 decoration是互斥的，两个只能设置一个， decoration功能更强大，可以设置非常炫酷的效果。 5、foregroundDecoration 前台装饰，先绘制背景和child，最后再绘制 foregroundDecoration，会挡住child。 6、transform 矩阵变换，可以是移动、缩放、绕x或y或z轴旋转、或者多个复合的变换。 7、clipBehavior枚举 none：无模式hardEdge：裁剪速度稍快，但容易失真，有锯齿。 antiAlias：裁剪边缘抗锯齿，使得裁剪更平滑，这种模式裁剪速度比antiAliasWithSaveLayer快，但是比hardEdge慢，该模式常用于圆形和弧形之类的形状裁剪。 antiAliasWithSaveLayer：裁剪后具有抗锯齿特性并分配屏幕缓冲区，所有后续操作在缓冲区进行，然后再进行裁剪和合成。 默认是none，这个属性一般情况下用不到。 结束语：Container是非常常用且实用的小组件，很有必要深入理解它。 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/flutter/组件解析之Container.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/flutter/组件解析之Container.html\"});gitalk.render(\"gitalk-container\"); "},"flutter/Wrap控件介绍.html":{"url":"flutter/Wrap控件介绍.html","title":"Wrap控件介绍","keywords":"","body":"2. Wrap控件 Wrap( spacing: space, runSpacing: space, alignment: WrapAlignment.center, runAlignment: WrapAlignment.center, verticalDirection: VerticalDirection.up, textDirection: TextDirection.rtl, children: avatars.reversed .map((e) => DUIAvatar( url: e, radius: 2, width: w, height: h, loadingWidget: loadingWidget, failedWidget: failedWidget, )) .toList(), ) Wrap({ Key key, this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, this.clipBehavior = Clip.hardEdge, List children = const [], }) 3. 疑问 Flutter里面如何push一个类似alert的页面，让透明的地方的点击响应传给上一个页面 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/flutter/Wrap控件介绍.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/flutter/Wrap控件介绍.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/":{"url":"iOS/","title":"iOS","keywords":"","body":"iOS Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/README.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/CreateML.html":{"url":"iOS/CreateML.html","title":"CreateML","keywords":"","body":"Create ML实践 Core ML 让你可以轻松将机器学习模型应用于你的 App 中。但是这些模型从哪里来，除了直接网上下载WWDC 2018 - Session 703 Introducing Create ML里面苹果给出了自己的机器学习方案，使用Mac和Swift就可以训练自己的模型。简介可以参考这篇文章 一般机器学习步骤 遇到问题->收集数据->训练->评估->模型 这里给一个简单例子 遇到问题：我想把云盘里面的视频和电视剧分类一下 电影和电视下载太费时间了，可不可以通过名字来分类呢？ 收集数据：简单收集影音博物馆里面的电影名字和电视剧名字 要找一个可以快速获取电影和电视名字的地方，一下就想到了影音博物馆 然后训练和评估以及导出模型交给Create ML import CreateML let videoExts = Set(arrayLiteral: \"MP4\", \"MOV\", \"MKV\", \"3GP\", \"MPV\", \"AVI\", \"RMVB\", \"WMF\", \"MPG\", \"RM\", \"ASF\", \"MPEG\", \"WMV\", \"FLV\", \"F4A\", \"WEBM\", \"VOB\", \"M4V\") let path = \"/Users/qin/Desktop/a.txt\" let fileText = try! String(contentsOf: URL(fileURLWithPath: path)) let text = (fileText as NSString).replacingOccurrences(of: \"\\\\\", with: \"/\") let array = text.components(separatedBy: \"\\n\") let movies = array.filter { $0.contains(\"电影协会-影音博物馆/★影视/电影/\") } let tvs = array.filter { $0.contains(\"电影协会-影音博物馆/★影视/剧集/电视剧\") } let movieNames = movies.filter { videoExts.contains(($0 as NSString).pathExtension.uppercased()) }.map{ ($0 as NSString).lastPathComponent } let tvNames = tvs.filter { videoExts.contains(($0 as NSString).pathExtension.uppercased()) }.map{ ($0 as NSString).lastPathComponent } print(\"movie count:\\(movieNames.count) tv count: \\(tvNames.count)\") print(\"Specify Data Create Model\") let classifier = try MLTextClassifier(trainingData: [\"movie\": movieNames, \"tv\": tvNames]) let evaluation = classifier.evaluation(on: [\"movie\": [\"复仇者联盟\", \"大话西游2\"], \"tv\": [\"延禧攻略.2018.720p.X264.第34集\", \"延禧攻略.2018.720p.X264.第36集\"]]) print(\"Evaluate Model \\n\\(evaluation.description)\") print(\"Save Model\") try classifier.write(toFile: \"/Users/qin/Desktop/Test/VideoClassifier.mlmodel\") Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/CreateML.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/CreateML.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/IntroducingCreateML.html":{"url":"iOS/IntroducingCreateML.html","title":"Introducing Create ML","keywords":"","body":"Introducing Create ML 去年加入的CoreML framework大获成功，相信许多开发者都已经尝试在自己的app里加入机器学习的功能了，然而从哪里获取模型的问题一直不太好解决。即使苹果提供了一个python工具 --- CoreML Tool，可以将caffe等模型转成coreML模型，但支持的文件类型有限（后面支持了大多数类型），我尝试过，对于我这种ML领域小白，感觉也不太好用。所以苹果今年提供了一个全新的库---createML，他是swift专属的framework，可以解决获取CoreML模型的难题。 这个topic主要介绍了 Transfer Learning（迁移学习） 图像识别 文本识别 表格数据推断 通过createML和CoreML，可以只用swift一种语言，在mac上解决创建/训练/评估模型-跑模型-部署到端上运行，并且训练、评估模型都是一两句代码就可以实现。对于iOS开发者来说，引入机器学习的成本可以说非常低了，值得关注。CreateML目前只能训练三种类型的数据：图像、文字和表格数据。对应目前的识别能力就是图像、文本识别和根据表格数据推断等。 Transfer Learning 我准备开始训练数据，然而难题出现了，我上哪找大量用来训练的数据？ 得益于transfer learning，仅仅需要少量数据就足够了。由于苹果本身在端上已经内置了多个自己的识别模型（应该是一些大文件，苹果训练了多年的数据），我们训练的模型是基于苹果模型的一种增强，具体就是将他的模型最后几层layer重新根据我们的数据训练。最终做推断时会结合苹果的训练结果和你提供的数据的训练结果来推断。 通过createML重新训练苹果模型的最后几层，最终输出一个coreML模型，这样训练时间大大减少，甚至几秒钟就能训练完成。模型大小也能从100MB级别减少到KB级别（这里我试了下，用Create ML训练的简单模型普遍只有几十kb，用基于python的Turi Create训练出来的动不动几百MB）。 transfer learning让模型可以复用，个人开发者可以轻松训练出体积小的模型，让app更加智能。同时体积小的文件方便下发到端上，甚至内置在安装包里发布。 图像 首先要自己将图像数据分类好，准备好用来训练的数据和用来评估的数据。下图是一种分类方式，将每种类型的图片放在一个文件夹里。然后创建一个swift playground 注意：需要macOS mojave 10.14Beta，Xcode10Beta，并且playground项目最好放在桌面，多试几次import CreateML才能出来。 两行代码，run，就出现一个可视化的窗口 png或jpg文件都可以，尺寸没有要求，把TestImages文件夹和TrainImages文件夹分别拖进来就可以了，当然也可以用纯代码的方式训练，流程是： 指定数据源 - 创建模型 - 评估模型 - 保存模型 如下图。 纯代码训练和评估模型，#!/usr/bin/swift变成可执行文件 这里我使用了https://github.com/Rubenfer/CreateML里提供的图片，故意使用8张图片来训练，只有猫和狗两种类型，19张图片用来评估预测，准确率居然100%，模型文件只有17KB。 然后我将dog文件夹名字改成cat，cat改成dog，发现识别准确率依然100%，对于错误分类的数据也能“正确”的预测出来，当然，你给一张猫狗以外的图片肯定识别错，因为结果枚举里只有猫狗这两种。不过transfer learning还是很牛逼了。 如果对模型满意，只要将模型文件拖到项目里即可，具体CoreML文件的使用参考去年的https://developer.apple.com/videos/play/wwdc2017/703 建议自己尝试https://github.com/Rubenfer/CreateML 文本 data source的格式支持以文件夹分类的txt文本、csv文件和json格式的文件。 文本识别的流程被极大简化了，识别前的语言预测和文本分段都不需要考虑。流程和图片识别类似，只是将MLImageClassifier换成了MLTextClassifier，如下图。 文件夹作为数据源的NLP workflow json文件作为数据源，使用MLDataTable 虽然今年NLP支持了中文的词性识别和中文机构识别，但我在testData里加入中文好像导致死循环了，不太确定中文数据能否用在createML里。 关于NLP的使用，以前是用NSLinguisticTagger，今年有了一整套新的NL开头的api，参考https://developer.apple.com/videos/play/wwdc2018/713/ 建议自己尝试https://github.com/Flight-School/Programming-Language-Classifier，可以获得一个能够识别多种编程语言的模型文件。 识别准确率高达99.64% 表格（TabularData） createML使用MLDataTable来处理表格数据，datasource支持csv、json，它是基于Turi的。 表格的行是一个example，列是一个feature，通常选取一个列作为target来预测，以example为单位挖掘每个feature之间的关系。这里把price作为target，评估数据时target列的数据对于模型是隐藏的，通过挖掘到的关系来对price做一个inference（预测），再和真实数据里的price比较，评估准确率。 可以方便地筛选想要的example 流程和上面的类似。randomSplit可以将你提供的数据源随机按比例划分成训练数据和评估数据。这里返回的元组，80%的数据是用来训练的，20%是用来评估的。table数据的训练有很多训练器，包括MLBoostedTreeRegressor、MLDecisionTreeRegressor、MLRandomForestRegressor、MLLinearRegressor等，如果不知道要用哪个，可以直接用MLRegressor，他会自动选择一个最合适的。 TabularData workflow 总结 我的理解：createML训练出来的模型必然是依赖苹果模型的，其实本质是用苹果的模型来识别，所以离开苹果的环境应该无法使用。而我们日常开发中费很大力气训练出一个可用的模型，是希望它能运行在多平台的，这样看来CreateML最终产出的CoreML只支持iOS/macOS，在这点上有很大局限性，所以这可能是苹果接下来要解决的另一个难题。 能否让CoreML运行在android等其他平台，将成为CoreML普及的一个关键，目前来看只有纯粹的开发iOS/macOS平台的个人开发者会使用CoreML和CreateML。 虽然如此，我们还是应该开始尝试，毕竟ML的准入门槛已经降低了很多，以后ML也必将成为每个app的标配。 这里给一个简单例子 遇到问题：我想把云盘里面的视频和电视剧分类一下 电影和电视下载太费时间了，可不可以通过名字来分类呢？ 收集数据：简单收集公司影音博物馆里面的电影名字和电视剧名字 要找一个可以快速获取电影和电视名字的地方，一下就想到了影音博物馆 然后训练和评估以及导出模型交给Create ML let videoExts = Set(arrayLiteral: \"MP4\", \"MOV\", \"MKV\", \"3GP\", \"MPV\", \"AVI\", \"RMVB\", \"WMF\", \"MPG\", \"RM\", \"ASF\", \"MPEG\", \"WMV\", \"FLV\", \"F4A\", \"WEBM\", \"VOB\", \"M4V\") let path = \"/Users/qin/Desktop/a.txt\" let fileText = try! String(contentsOf: URL(fileURLWithPath: path)) let text = (fileText as NSString).replacingOccurrences(of: \"\\\\\", with: \"/\") let array = text.components(separatedBy: \"\\n\") let movies = array.filter { $0.contains(\"讯电影协会-影音博物馆/★影视/电影/\") } let tvs = array.filter { $0.contains(\"讯电影协会-影音博物馆/★影视/剧集/电视剧\") } let movieNames = movies.filter { videoExts.contains(($0 as NSString).pathExtension.uppercased()) }.map{ ($0 as NSString).lastPathComponent } let tvNames = tvs.filter { videoExts.contains(($0 as NSString).pathExtension.uppercased()) }.map{ ($0 as NSString).lastPathComponent } print(\"movie count:\\(movieNames.count) tv count: \\(tvNames.count)\") print(\"Specify Data Create Model\") let classifier = try MLTextClassifier(trainingData: [\"movie\": movieNames, \"tv\": tvNames]) let evaluation = classifier.evaluation(on: [\"movie\": [\"复仇者联盟\", \"大话西游2\"], \"tv\": [\"延禧攻略.2018.720p.X264.第34集\", \"延禧攻略.2018.720p.X264.第36集\"]]) print(\"Evaluate Model \\n\\(evaluation.description)\") print(\"Save Model\") try classifier.write(toFile: \"/Users/qin/Desktop/Test/VideoClassifier.mlmodel\") Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/IntroducingCreateML.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/IntroducingCreateML.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/AGuidetoTuriCreate.html":{"url":"iOS/AGuidetoTuriCreate.html","title":"A Guide to Turi Create","keywords":"","body":"WWDC 2018 - Session 712 A Guide to Turi Create Turi Create 是一个python包，帮助你创建Core ML模型 使用简单，你不用成为ML专家，甚至无需机器学习背景就可以使用 使用方便，把关注任务放到了首位 把复杂的机器学习算法抽象化了，让开发者可以专心于想要创建的用户体验 跨平台 Mac和Linux都可以使用 Github开源 快速使用 > pip install turicreate 五步创建Core ML 理解你想要完成的任务，以及我们如何使用机器学习的术语描述该任务 明白完成任务所需要的数据类型，还有需要多少数据 创建模型 评估创建的模型质量 导出Core ML添加到你的代码里 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/AGuidetoTuriCreate.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/AGuidetoTuriCreate.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/ATourOfUicollectionview.html":{"url":"iOS/ATourOfUicollectionview.html","title":"CollectionView 之旅","keywords":"","body":"WWDC 2018 ：CollectionView 之旅 本文是 WWDC 2018 Session 225 读后感，其视频及配套 PDF文稿 地址如下 A Tour Of UICollectionView。 这篇文章难度不大，由易到难，逐层深入，是一篇很好的 Session。全文总计约2500字，通读全文花费时间大约15分钟。 看完这篇 Session，给我的直观感受是这篇名为 A Tour Of UICollectionView 的文章，是围绕着一个 CollectionView 的案例，对自定义布局以及其性能优化、数据操作、动画做的一次探讨。虽然没有新增的 API 和特性，但是实际意义蛮大。 我们也按照 Session 的思路，将本文主要分为三个模块： CollectionView 概述 布局（自定义 Layout） 数据的刷新、动画 CollectionView 想必各位已经不陌生了，在我们的日常开发中，它的身影随处可见。如果还有小伙伴对它不熟悉，可以看看之前的 Session ： WWDC 2016 - What`s New In CollectionView In iOS 10 。 WWDC 2017 - Drag and Drop with Collection and Table View。 如果我们想搭建一个如下图的 App ，需要涉及到三点：布局、刷新、动画，我们今天的话题也是围绕着这三点展开。 CollectionView 概述 CollectionView 的核心概念有三点：布局（Layout）、数据源（Data Source）、代理（Delegate）。 UICollectionViewLayout UICollectionViewLayout 负责管理 UICollectionViewLayoutAttributes，一个 UICollectionViewLayoutAttributes 对象管理着一个 CollectionView 中一个 Item 的布局相关属性。包括 Bounds、center、frame 等。同时要注意在当 Bounds 在改变时是否需要刷新 Layout, 以及布局时的动画。 UICollectionViewFlowLayout UICollectionViewFlowLayout 是 UICollectionViewLayout 的子类,是系统提供给我们一个封装好的流式布局的类。 横向流式布局（白色线代表布局方向） 纵向流式布局（白色线代表布局方向） 这种流式布局需要区分方向，方向不同，具体的 Line Spacing 和 Item Spacing 所代表的含义不同，具体差异，可以通过上面的两张图进行区分。 因为流式布局其强大的适用性，所以在设计中这种布局方式被广泛使用。 UICollectionViewDataSource 数据源：顾名思义，提供数据的分组信息、每组中 Item 数量以及每个 Item 的实际内容。 optional func numberOfSections(in collectionView: UICollectionView) -> Int func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell 复制代码 UICollectionViewDelegate delegate 提供了一些细颗粒度的方法： Highlighting Selection 还有一些视图的显示事件： willDisplayItem didEndDisplayingItem 布局 - 自定义 Layout 系统提供的 UICollectionViewFlowLayout 虽然使用起来方便快捷，能够满足基本的布局需要。但是遇到如下图的布局样式，显然就无法达到我们所需的效果，这时就需要自定义 FlowLayout了。 自定义 FlowLayout 并不复杂 ，有以下四步： 1.提供滚动范围 override var collectionViewContentSize: CGSize 复制代码 2.提供布局属性对象 func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? func layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? 复制代码 3.布局的相关准备工作 // 为每个 invalidateLayout 调用 // 缓存 UICollectionViewLayoutAttributes // 计算 collectionViewContentSize func prepare() 复制代码 4.处理自定义布局中的边界更改 // 在 CollectionView 滚动时是否允许刷新布局 func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool 复制代码 性能优化部分 通过以上的方法，我们可以轻松实现自定义 layout 的布局。但是在实际开发中，有一个对性能提升很实用的小技巧很值得我们借鉴。 通常，我们获取当前屏幕上所有显示的 UICollectionViewLayoutAttributes 会这么写 override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? { return cachedAttributes.filter { (attributes:UICollectionViewLayoutAttributes) -> Bool in return rect.intersects(attributes.frame) } } 复制代码 采用以上的写法，我们会遍历缓存了所有 UICollectionViewLayoutAttributes 的 cachedAttributes 数组。而随着用户的拖动屏幕，这个方法会被频繁的调用，也就是会做大量的计算。当 cachedAttributes 数组的量级达到一定的规模，对性能的负面影响就会非常明显，用户在使用过程中会出现卡顿的负面体验。 苹果工程师采用的办法可以很好地解决这一问题。所有的 UICollectionViewLayoutAttributes 都按照顺序被存储在 cachedAttributes 数组中，既然是一个有序的数组，那么只要我们通过二分查找，拿到任何一个在当前页面显示的 Attribures 对象，就可以以这个 Attribures 对象为中心，向前向后遍历查找符合条件的 Attribures 对象即可，这样查找的范围就被大大缩小了。相应地，计算量变小，对性能的提升非常明显。 为了让大家易于理解，画了一张图，虽然有点丑，但表达思想足够了。 当前显示的 CollectionView 的范围就是 rect。在 rect 内部通过二分查找，找到第一个合适的 UICollectionViewLayoutAttributes 作为 firstMatchIndex，也就是那个 Attributes 对象。 在 rect 内， firstMatchIndex 以上的 Attributes 都符合 attributes.frame.maxY >= rect.minY，而在 firstMatchIndex 以下的 Attributes 也都符合 attributes.frame.maxY 的条件。 优化后的代码如下 override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? { var attributesArray = [UICollectionViewLayoutAttributes]() // 找到在当前区域内的任何一个 Attributes 的 Index guard let firstMatchIndex = binarySearchAttributes(range: 0...cachedAttributes.endIndex, rect:rect) else { return attributesArray } // 从后向前反向遍历，缩小查找范围 for attributes in cachedAttributes[..= rect.minY else {break} attributesArray.append(attributes) } // 从前向后正向遍历，缩小查找范围 for attributes in cachedAttributes[firstMatchIndex...] { guard attributes.frame.minY 通过二分查找的方式，在处理当前页面显示的 UICollectionViewLayoutAttributes 的过程中可以减少遍历的数据量，在实际体验中页面滑动更加顺滑，体验更好，这种处理 Attribures 对象的方式，值得我们在开发过程中借鉴。 数据刷新和动画 我们会遇到对 CollectionView 进行编辑的场景，编辑操作一般是新增、删除、刷新、插入等。在本 Session 中，主讲人为我们做了一个示例。 对最后一条数据进行刷新操作 将原本在最后位置的数据移动到第一条的位置 删除原本的第三条数据 为了便于理解，还是贴一下代码吧： // 原函数 func performUpdates() { people[3].isUpdated = true let movedPerson = people[3] people.remove(at:3) people.remove(at:2) people.insert(movedPerson, at:0) // Update Collection View collectionView.reloadItems(at: [IndexPath(item:3, section:0)]) collectionView.reloadItems(at: [IndexPath(item:2, section:0)]) collectionView.moveItem(at: IndexPath(item:3, section:0), to:IndexPath(item:0, section:0)) } 复制代码 这个例子在操作过程中报错，原因如下：我们删除和移动的是同一个索引位置的元素。我们显示地调用了 reloadData() , reloadData() 是一个异步执行的函数，会直接访问数据源方法，进行重新布局，多次调用容易出错，同时这样写也没有动画效果。 performBatchUpdates 上面出错的场景其实挺常见，为了规范操作，避免在编辑的场景下出现问题，应当将对 CollectionView 的新增、删除、刷新、插入等操作都放入到 performBatchUpdates() 中的 updates 闭包内，CollectionView 中 Item 的更新顺序我们不需要关心，但是数据源更新的顺序是很重要的。 首先认识一下这个方法 func performBatchUpdates(_ updates: (() -> Void)?, completion: ((Bool) -> Void)? = nil) 1.其中 updates 闭包内部会执行新增、删除、刷新、插入等一系列操作。 2.而 completion 闭包会在 updates 闭包执行完毕后开始执行，updates 闭包中的相关操作会触发一些动画， 当这些动画执行成功会返回 True，当动画被打断或者执行失败会返回 false，这个参数也有可能会返回 nil。 复制代码 这个方法可以用来对 collectionView 中的元素进行批量的新增、删除、刷新、插入等操作，同时将触发collectionView 的 layout 的对应动画: 1.func initialLayoutAttributesForAppearingItem(at itemIndexPath: IndexPath) -> NSCollectionViewLayoutAttributes? 2.func initialLayoutAttributesForAppearingDecorationElement(ofKind elementKind: NSCollectionView.DecorationElementKind, at decorationIndexPath: IndexPath) -> NSCollectionViewLayoutAttributes? 3.func finalLayoutAttributesForDisappearingItem(at itemIndexPath: IndexPath) -> NSCollectionViewLayoutAttributes? 4.func finalLayoutAttributesForDisappearingDecorationElement(ofKind elementKind: String, at decorationIndexPath: IndexPath) -> UICollectionViewLayoutAttributes? 复制代码 原因是因为在执行完 performBatchUpdates 操作之后，CollectionView 会自动 reloadData 调用数据源方法重新布局。所以我们在 Updates 闭包中对数据的编辑操作执行完毕后，一定要同步更新数据源，否则有极大的几率出现数据越界等错误情况。 易出错的合并更新一般有以下几种 1.移动与删除同一个索引 2.移动与插入同一个索引 3.将多个对象移动到同一个索引 4.引用了一个无效的索引 既然在执行操作时容易出现问题，我们就该想办法去规避，苹果的工程师给出了很好的建议。在上面我们讲过对 CollectionView 的新增、删除、刷新、插入等操作都放入到 performBatchUpdates() 中的 updates 闭包内，CollectionView 中 Item 的更新顺序我们不需要关心，但是数据源更新的顺序很重要。最后的 Item 更新顺序和数据源的更新顺序是怎么回事呢？ 你可以这样理解： 在 Updates 闭包内，你可以选择先删除一个索引，然后插入一个新的索引，或是把两者的顺序颠倒过来进行操作，这都没有问题，你可以按照自己的喜好，随意指定顺序。 但是涉及到数据源更新的方法，必须按照一定的顺序和规则来操作。 数据源执行操作的顺序及规则 1.将移动操作拆分成删除和插入。 2.将所有的删除操作合并到一起，同理将所有的插入操作也合并到一起。 3.以降序优先处理删除操作。 4.最后以升序处理插入操作。 然后我们将刚才出错的代码，改为如下： // 新的实现 func performUpdates() { UIView.performWithoutAnimation { // 先将数据刷新 collectionView.performBatchUpdates({ people[3].isUpdate = true collectionView.reloadItems(at: [IndexPath(item:3, section:0)]) }) } // 再将移动拆分成删除之后再插入两个动作 collectionView.performBatchUpdates({ let movedPerson = people[3] people.remove(at: 3) people.remove(at: 2) people.insert(movedPerson, at:0) CollectionView.deleteItems(at: [IndexPath(item:2, section:0)]) collectionView.moveItem(at: IndexPath(item:3, section:0), to:IndexPath(item:0, section:0)) }) } 复制代码 最后总结一下，苹果的工程师建议我们通过自定义布局来实现精美的布局样式，同时采取二分查找的方式来高效的处理数据，提升界面的流畅性和用户体验。 其次对 CollectionView 的操作建议我们通过 performBatchUpdates 来进行处理，我们不需要去考虑动画的执行，因为默认都帮助我们处理好了，我们只需要注意数据源处理的原则和顺序，确保数据处理的安全与稳定。 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/ATourOfUicollectionview.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/ATourOfUicollectionview.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/DragDrop.html":{"url":"iOS/DragDrop.html","title":"DragDrop","keywords":"","body":"苹果最近发布了iOS11beta版，里面有很多激动人心的API，我们这里先体验一下DragDrop。Drag做为定义方提供一个可以拖拽的东西，可以是图片或文件等任意的东西。Drop是作为接收方，你可以指定你可以接收一些什么东西。 我们这里以一个UICollectionView为例子，这里苹果已经给我们实现了这两个协议。 @property (nonatomic, weak, nullable) id dragDelegate API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(tvos, watchos); @property (nonatomic, weak, nullable) id dropDelegate API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(tvos, watchos); 我们只要做很少的事情就可以搞定了一个简单的DragDrop了 一、首先在你的CollectionViewController里面指定协议 if (@available(iOS 11.0, *)) { self.collectionView.dropDelegate = self; self.collectionView.dropDelegate = self; } 二、实现Drop协议 1.首先制定接收拖拽的方式，我们这里指定为copy，这样默认实现就不会移除drag位置的cell - (UICollectionViewDropProposal *)collectionView:(UICollectionView *)collectionView dropSessionDidUpdate:(id)session withDestinationIndexPath:(nullable NSIndexPath *)destinationIndexPath { return [[UICollectionViewDropProposal alloc] initWithDropOperation:UIDropOperationCopy]; } 2.指定是否可以接收拖拽的东西，这里可以通过session的方法 hasItemsConformingToTypeIdentifiers: 判断是否是你可以处理的拖拽类型，比如这里只处理拖过来的图片 - (BOOL)collectionView:(UICollectionView *)collectionView canHandleDropSession:(id)session { return [session hasItemsConformingToTypeIdentifiers:@[(NSString *)kUTTypeImage]]; } 3.处理拖拽过来的数据 - (void)collectionView:(UICollectionView *)collectionView performDropWithCoordinator:(id)coordinator { if (coordinator.session.localDragSession) { //来自自己当前APP的拖拽,可以直接拿到drag的时候自定义的数据 CGPoint point = [coordinator.session.localDragSession locationInView:collectionView]; NSIndexPath *indexPath = [collectionView indexPathForItemAtPoint:point]; //拿到了松手时候的目标cell 可以拿来做动画 [coordinator.items enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { UIDragItem *dragItem = obj.dragItem; if (dragItem.localObject) { id object = dragItem.localObject; //这里就是drag的时候传的自定义数据 } }]; } else { // \b\b来自别的APP的拖拽，这里需要从别的APP下载数据 [coordinator.items enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { UIDragItem *dragItem = obj.dragItem; [dragItem.itemProvider loadFileRepresentationForTypeIdentifier:(NSString*)kUTTypeJPEG completionHandler:^(NSURL * _Nullable url, NSError * _Nullable error) { //下载到拖拽过来的数据了 }]; }]; } } 三、实现Drag协议 1.定制拖拽的对象，需要实现一个NSItemProviderWriting协议，告诉目标APP我们拖的是一个什么类型的数据，然后把数据处理一下给目标APP，还可以给一个处理进度给目标APP @interface WYDragFileItem : NSObject @end @implementation WYDragFileItem + (NSArray*)writableTypeIdentifiersForItemProvider { return @[(NSString*)kUTTypeJPEG, (NSString *)kUTTypeImage]; } - (nullable NSProgress *)loadDataWithTypeIdentifier:(NSString *)typeIdentifier forItemProviderCompletionHandler:(void (^)(NSData * _Nullable data, NSError * _Nullable error))completionHandler { //这里面可以是一个下载方法或者压缩方法或者格式转换方法，允许给一个进度让目标位置显示，可异步 completionHandler(UIImagePNGRepresentation([UIImage imageNamed:@\"image\"]), nil); return nil; } @end 2.开始拖拽的时候包装拖拽数据 - (NSArray *)collectionView:(UICollectionView *)collectionView itemsForBeginningDragSession:(id)session atIndexPath:(NSIndexPath *)indexPath { NSItemProvider *provider = [[NSItemProvider alloc] initWithObject:dragObject]; //dragObject 是一个实现NSItemProviderWriting协议的数据，一会下面介绍 UIDragItem *item = [[UIDragItem alloc] initWithItemProvider:provider]; item.localObject = anyObject; //anyObject 是可以传递的任意自定义数据 return @[item]; } 这样一个简单的拖拽流程就完成了，细节或动画等这里就不写了，具体可以相互探讨一下。 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/DragDrop.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/DragDrop.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/一种强大的布局方案.html":{"url":"iOS/一种强大的布局方案.html","title":"一种强大的布局方案","keywords":"","body":"做项目的时候遇到一些界面需要的布局非常自由而网上搜了一些开源的代码都没找到一个理想的，于是自己就准备写一种比较理想的布局，一种可以像系统的UICollectionViewFlowLayout一样从左到右的流式布局，又能像CHTCollectionViewWaterfallLayout一样的从上到下瀑布流布局，并且完全能兼容这两种布局的能力，想到就做(就算不能一步到位也可以慢慢实现直到解决问题)。 这里首先来看一下UICollectionViewFlowLayout的一种布局情况可以看到这么多空白位置多浪费，这也是我想写一个布局的原因之一(浪费可耻) 然后在看一个网上写的比较好的布局CHTCollectionViewWaterfallLayout显示情况虽然不浪费空间了，但是有一个致命的问题(宽度都是一样的)，对于一个追求完美的程序员来所这完全是无法容忍的(作者不要打我。我这里只是说不够理想，并不是说这个布局不够好，这个布局是我在GitHub上见过写得最好的了)... 下面看一个理想中的布局为了这个理想布局我开始了撸代码。 这里首先打下草稿定下几点实现思路(这里就不讲layout定制的基础教程了，网上一大片)1.布局方向采用从上到下从左到右(就类似下的雨留到河流里面的继续往海里流一样)2.所有复杂页面的布局都能通过业务层给出适当的size实现3.完全可以像系统的UICollectionViewFlowLayout一样使用，这里接口几乎跟系统API一毛一样4.理想状态是性能要高 最开始一直没想到一个好的办法计算这种从上到下从左到右的布局，直到有一天撸代码的时候使用到了NSIndexSet，突然灵光一闪想到了这个NSIndexSet完全可以解决这种理想的layout的布局计算。于是在我撸啊撸的情况下总算撸出来了一个初版。为什么叫初版呢? 是因为虽然功能是实现了，但是细节和性能还有待提升！这需要后续持续完善。 下面给出初版的性能测试对比（测试设备:iPhone6，数据量:10万） function preparLayout layoutAttributesForElementsInRect 内存使用(1条数据的时候4.9MB) UICollectionViewFlowLayout 258.518 ms 1.100 ms 20.9 MB CHTCollectionViewWaterfallLayout 864.026 ms 1.613 ms 35.6 MB WYWaterFlowLayout 2292.417 ms 2.088 ms 51.6 MB 当然10万数据有点大 这里给个1万数据的测试 function preparLayout layoutAttributesForElementsInRect 内存使用 UICollectionViewFlowLayout 25.087 ms 0.614 ms 6.7 MB CHTCollectionViewWaterfallLayout 80.257 ms 0.271 ms 8.8 MB WYWaterFlowLayout 160.849 ms 0.209 ms 10.3 MB  看这个测试数据勉强还能接受，除了布局时间长一点，滑动性能还可以，基本算可以使用了。但是对于一个励志要改变世界的程序员来说必须得追求极限，这里跟CHTCollectionViewWaterfallLayout对比性能相差了将近一倍，性能瓶颈主要在下面这个函数，因为10万数据的测试1645.468ms里面有1200ms都是这个函数消耗的,通过优化这个函数可以大幅度提升性能。 - (CGRect)willAddItemWithSize:(CGSize)size maxWidth:(CGFloat)maxWidth maxTop:(CGFloat *)p_top withSpaces:(NSMutableArray *)emptySpaces 这个函数主要是传入一个需要布局的item的size、布局所在的宽度和空白位置记录数据，返回这个item的frame和当前布局到的最大y坐标，这个函数也是这个布局最核心的函数了，函数主要是做了三件事1.根据已有空位记录找到要插入的item可以放的位置2.更新空白位置记录，比插入item低的空位被它占用，比插入item高的会占用当前的空位3.把空位记录按低到高左到右排序​生活中一切目标都能通过解决N个问题实现 ---- 刚想出来的。 这里争取只遍历一遍就完成查找排序更新，想到就做。首先这里通过优化排序算法，把2292.417ms的运算时间降低到了1220.73ms；然后通过简化数据结构把运算时间降低到1000ms左右，勉强可用了。 下面附上简化后的性能测试数据（测试设备:iPhone6，数据量:10万） function preparLayout layoutAttributesForElementsInRect 内存使用(1条数据的时候4.9MB) UICollectionViewFlowLayout 258.518 ms 1.100 ms 20.9 MB CHTCollectionViewWaterfallLayout 864.026 ms 1.613 ms 35.6 MB WYWaterFlowLayout 1076.112 ms 1.776 ms 50.4 MB 当然10万数据有点大 这里给个1万数据的测试 function preparLayout layoutAttributesForElementsInRect 内存使用 UICollectionViewFlowLayout 25.087 ms 0.614 ms 6.7 MB CHTCollectionViewWaterfallLayout 80.257 ms 0.271 ms 8.8 MB WYWaterFlowLayout 98.604 ms 0.246 ms 10.4 MB 这里跟CHTCollectionViewWaterfallLayout的性能已经很接近了，在复杂度提高的情况下能把性能控制得差不多这里也算基本满意了。 后续可以继续优化这里的计算，以及像素点对齐。 Demo License WYWaterFlowLayout is available under the MIT license. See the LICENSE file for more info. Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/一种强大的布局方案.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/一种强大的布局方案.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/一行代码的约束解决方案.html":{"url":"iOS/一行代码的约束解决方案.html","title":"一行代码的约束解决方案","keywords":"","body":"众所周知Apple提供的约束接口非常不好用，我们开发的时候基本都是用的第三方开源约束组件(比如Masonry，然后这套组建源码比较多，估计没几个人去完整的看完它的源码)，用起来也不是非常简洁。 虽然iOS9开始Apple已经意识到了这一点做了相应的更新但是他们的接口还是使用比较不方便。当然swift最新的约束写法是要好很多，基本赶上Masonry了，然而我们现在大多项目还是不能完全使用swift，所以objc的约束我们还是要继续用，由于我比较懒，就算swift最新的约束写法也不能满足我，于是我就开始思考有什么办法可以让我们写约束的时候可以非常简单最好一行代码能解决呢。 因为我们大多数App已经从iOS9开始支持了，于是就基于iOS9的UIViewLayoutConstraintCreation封装了一套简单的约束解决方案，所有代码加起来不到200行，非常简单高效只有一个函数不到50行的代码非常容易理解、想加功能接口非常简单。这套组建你只用花几分钟就可以看完源码了，大多数代码都是接口。实现日常编码中大多数约束都能通过一行代码实现。走过路过千万不要错过，200行代码你看了不吃亏看了不上当。 首先上核心代码，就下面这一个宏函数，理解这个函数就差不多理解了整个方案，其它代码几乎都是调用这个函数（可以先不看他，看完后面的展开函数后回来看也一样） #define wy_layout_item(value, func, safeArea, propertyName) \\ NSLayoutConstraint *layout = nil;\\ if ([value isKindOfClass:UIView.class] || [value isKindOfClass:NSNumber.class] || [value isKindOfClass:NSLayoutAnchor.class]) {\\ UILayoutGuide *(^wykit_getGuide)(UIView *view) = ^(UIView *view) {\\ if (@available(iOS 11.0, *)) {\\ if (safeArea) block_return view.safeAreaLayoutGuide;\\ }\\ block_return (UILayoutGuide *)view;\\ };\\ \\ UILayoutGuide *guide = wykit_getGuide(self.view.superview);\\ NSLayoutAnchor *xAnchor = [self.view value##Anchor];\\ NSLayoutAnchor *anchor = ([xAnchor isKindOfClass:NSLayoutDimension.class]) ? nil : [guide value##Anchor];\\ CGFloat constant = 0;\\ if ([value isKindOfClass:UIView.class]) {\\ anchor = [wykit_getGuide(value) value##Anchor];\\ } else if ([value isKindOfClass:NSNumber.class]) {\\ constant = [value floatValue];\\ } else if ([value isKindOfClass:NSLayoutAnchor.class]) {\\ anchor = value;\\ }\\ \\ if ([xAnchor isKindOfClass:NSLayoutDimension.class]) {\\ if ([anchor isKindOfClass:NSLayoutDimension.class]) {\\ layout = [(NSLayoutDimension *)xAnchor func##Anchor:(NSLayoutDimension *)anchor constant:constant];\\ } else {\\ layout = [(NSLayoutDimension *)xAnchor func##Constant:constant];\\ }\\ } else {\\ layout = [xAnchor func##Anchor:anchor constant:constant];\\ }\\ layout.active = YES;\\ }\\ self.lastKeyPath = WYPropertyToText(value);\\ [self setValue:layout forKey:self.lastKeyPath];\\ self.lastConstraint = layout;\\ 可以看到里面value支持三种数据类型UIView、NSNumber、NSLayoutAnchor，且支持设置safeArea外加版本判断，还支持lessThan、greaterThan。参考函数式编程和链式调用下面我们实现top equal约束设置接口例子。 - (WYConstraints * (^)(id))wy_top { return ^id(id top){ wy_layout_item(top, constraintEqualTo, NO, ); block_return self; }; } 这样我们设置top约束就可以很简单的三种使用方式 view.wy_top(@0); //与父识图顶部对其 view.wy_top(otherView); //与otherView顶部对其 view.wy_top(otherView.bottomAnchor) //与otherView底部对其 下面附上这个wy_top函数的宏展开源码，可以看看具体实现（比那个宏函数直观一点） - (WYConstraints * (^)(id))wy_top { return ^id(id top){ NSLayoutConstraint *layout = nil; if ([top isKindOfClass:UIView.class] || [top isKindOfClass:NSNumber.class] || [top isKindOfClass:NSLayoutAnchor.class]) { UILayoutGuide *(^wykit_getGuide)(UIView *view) = ^(UIView *view) { if (@available(iOS 11.0, *)) { return view.safeAreaLayoutGuide; } return (UILayoutGuide *)view; }; UILayoutGuide *guide = wykit_getGuide(self.view.superview); NSLayoutAnchor *xAnchor = [self.view topAnchor]; NSLayoutAnchor *anchor = ([xAnchor isKindOfClass:NSLayoutDimension.class]) ? ((void *)0) : [guide topAnchor]; CGFloat constant = 0; if ([top isKindOfClass:UIView.class]) { anchor = [wykit_getGuide(top) topAnchor]; } else if ([top isKindOfClass:NSNumber.class]) { constant = [top floatValue]; } else if ([top isKindOfClass:NSLayoutAnchor.class]) { anchor = top; } if ([xAnchor isKindOfClass:NSLayoutDimension.class]) { if ([anchor isKindOfClass:NSLayoutDimension.class]) { layout = [(NSLayoutDimension *)xAnchor constraintEqualToAnchor:(NSLayoutDimension *)anchor constant:constant]; } else { layout = [(NSLayoutDimension *)xAnchor constraintEqualToConstant:constant]; } } else { layout = [xAnchor constraintEqualToAnchor:anchor constant:constant]; } layout.active = YES; } self.lastKeyPath = @\"top\"; [self setValue:layout forKey:self.lastKeyPath]; self.lastConstraint = layout;; return self; }; } 就top约束而言还需要实现下面6个接口函数 (因为链式调用所以函数命名尽量简短，不知道各路大神有没有更好的命名方式) wy_top wy_top_safeArea wy_top_less //这里其实应该是 wy_top_lessThanOrEqualTo 因为会链式调用，所以这里省略了后面部分 wy_top_lessSafeArea wy_top_greater wy_top_greaterSafeArea 我们还要实现left、bottom、right、width、height、centerX、centerY，加上top一共八种。 那么一共要实现 6 x 8 = 48个函数转发接口，然而让我一个一个去写是不可能的，所以继续用宏偷懒。如下48个函数搞定 #define WYConstraintsMethodAchieveWithItem(x) \\ - (WYConstraints * (^)(id))wy_##x {\\ return ^id(id x){\\ wy_layout_item(x, constraintEqualTo, NO, );\\ block_return self;\\ };\\ }\\ - (WYConstraints * (^)(id))wy_##x##_safeArea {\\ return ^id(id x){\\ wy_layout_item(x, constraintEqualTo, YES, SafeArea);\\ block_return self;\\ };\\ }\\ - (WYConstraints * (^)(id))wy_##x##_less {\\ return ^id(id x){\\ wy_layout_item(x, constraintLessThanOrEqualTo, NO, Less);\\ block_return self;\\ };\\ }\\ - (WYConstraints * (^)(id))wy_##x##_lessSafeArea {\\ return ^id(id x){\\ wy_layout_item(x, constraintLessThanOrEqualTo, YES, LessSafeArea);\\ block_return self;\\ };\\ }\\ - (WYConstraints * (^)(id))wy_##x##_greater {\\ return ^id(id x){\\ wy_layout_item(x, constraintGreaterThanOrEqualTo, NO, Greater);\\ block_return self;\\ };\\ }\\ - (WYConstraints * (^)(id))wy_##x##_greaterSafeArea {\\ return ^id(id x){\\ wy_layout_item(x, constraintGreaterThanOrEqualTo, YES, GreaterSafeArea);\\ block_return self;\\ };\\ } //打包实现接口函数 WYConstraintsMethodAchieveWithItem(top) WYConstraintsMethodAchieveWithItem(left) WYConstraintsMethodAchieveWithItem(bottom) WYConstraintsMethodAchieveWithItem(right) WYConstraintsMethodAchieveWithItem(width) WYConstraintsMethodAchieveWithItem(height) WYConstraintsMethodAchieveWithItem(centerX) WYConstraintsMethodAchieveWithItem(centerY) 后续在用宏把参数替换一下使value可以直接传数字，然后在加上一些方便使用的接口就完工了。 下面可以看一些具体使用的例子 view2.wy_left(view1).wy_right(view1).wy_height(30).wy_top(view1.bottomAnchor).offset(5); // 如果需要更新上面设置的height可以也可以简单搞定 wy_layout里面可以拿到每一种约束最后设置的那个 view2.wy_layout.height.constant = 50; 当然感觉这种链式调用太长的还可以使用下面这种等价的使用方式，是不是感觉很熟悉 [view2 wy_makeConstraints:^(WYConstraints *make) { make.wy_left(view1); make.wy_right(view1); make.wy_height(30); make.wy_top(view1.bottomAnchor).offset(5); }]; 后面用Swift实现一套转发接口兼容Swift（参考源码中的 UIView+WYConstraints.swift），由于不能使用宏，这里复制粘贴了144个函数非常蛋疼，求大神指点更优雅的实现方式。 下面是Swift的两种使用例子 aView.wy_left(100).wy_right(-10).wy_top_safeArea(10).wy_bottom(-100) OR aView.wy_makeConstraints { (make) in make?.wy_left(100) make?.wy_right(-10) make?.wy_top_safeArea(superView).offset(10) make?.wy_bottom(-100) } 优点 这个方案实现了几乎所有Masonry实现的功能，兼容系统约束方案，兼容Swift，并且源码非常少非常易于使用和维护以及自定义新功能等。 缺点 只支持iOS9或以上 下面附上源码和demo地址 欢迎交流学习以及完善。 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/一行代码的约束解决方案.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/一行代码的约束解决方案.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/制作动态库.html":{"url":"iOS/制作动态库.html","title":"制作动态库","keywords":"","body":"制作动态库 创建动态库项目这里以wx举例 按照微信的官方文档。添加依赖库 将wx的PublicHeader暴露出来，注意由于我并没有使用到wx相关API所以链接器帮我们链接动态库 的时候可能并不会把wx静态库吸附进来。我们手动在build Setting的other link flags加上-all_load标记 在Schema里面跳转编译配置为Release ，并且选择所有的CPU架构 然后选择模拟器或者Generic iOS Device运行编译就会生成对应版本的Framework了。 但是为了保证开发者使用的时候是真机模拟器都能正常使用，我们需要合并不同架构 这里在Build Phases里添加以下脚本，真机和模拟器都Build一遍之后就会在工程目录下生成Products文件夹， if [ \"${ACTION}\" = \"build\" ] then INSTALL_DIR=${SRCROOT}/Products/${PROJECT_NAME}.framework DEVICE_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework SIMULATOR_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework if [ -d \"${INSTALL_DIR}\" ] then rm -rf \"${INSTALL_DIR}\" fi mkdir -p \"${INSTALL_DIR}\" cp -R \"${DEVICE_DIR}/\" \"${INSTALL_DIR}/\" #ditto \"${DEVICE_DIR}/Headers\" \"${INSTALL_DIR}/Headers\" lipo -create \"${DEVICE_DIR}/${PROJECT_NAME}\" \"${SIMULATOR_DIR}/${PROJECT_NAME}\" -output \"${INSTALL_DIR}/${PROJECT_NAME}\" open \"${DEVICE_DIR}\" open \"${SRCROOT}/Products\" fi Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/制作动态库.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/制作动态库.html\"});gitalk.render(\"gitalk-container\"); "},"iOS/iOS转屏的坑和一些使用技巧.html":{"url":"iOS/iOS转屏的坑和一些使用技巧.html","title":"iOS转屏的坑和一些使用技巧","keywords":"","body":"项目中频繁的使用一些转屏，开发和维护过程中遇到很多坑，这里把转屏的基本流程和使用技巧分享一下。 一、首先介绍一下转屏的基本流程。 1.设备硬件加速计检测到方向变化的时候会发出UIDeviceOrientationDidChangeNotification通知。 2.app收到通知会询问AppDelegate的window支持的方向情况与window的rootViewController或rootViewController.presentedViewController(如果存在)所支持的方向做交集，然后完成旋转。 二、旋转控制函数有下面几个 - (BOOL)shouldAutorotate;// 将要自动旋转 返回 yes 为支持旋转，no 为不支持旋转 (这里有个坑，后面会讲) - (UIInterfaceOrientationMask)supportedInterfaceOrientations;// 支持的界面方向 - (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;// 首选方向，刚present进去时的方向 三、下面是两个实践例子 例子(1).先来一个简单的，一个只支持Portrait的界面A present 一个支持三个方向(UIInterfaceOrientationMaskAllButUpsideDown)的界面B，并且首选方向是左 这样很简单，在A中写两个函数 - (BOOL)shouldAutorotate { return NO; } - (UIInterfaceOrientationMask)supportedInterfaceOrientations { return UIInterfaceOrientationMaskPortrait; } 在B中写三个函数就搞定了 - (BOOL)shouldAutorotate { return YES; } - (UIInterfaceOrientationMask)supportedInterfaceOrientations { return UIInterfaceOrientationMaskAllButUpsideDown; } - (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation { return UIInterfaceOrientationLandscapeLeft; } 然后就可以直接看效果了 图片 这时候你会发现在界面B旋转屏幕到非Portrait后dismiss会crash，因为dissmiss的时候window会询问A的方向，和当前window方向做交集，交集为空就crash了，解决办法很简单，在dismiss之前转回A页面支持的方向就可以了，代码如下 - (instancetype)init { self = [super init]; if (self) { self.originDeviceOrientation = [UIDevice currentDevice].orientation; } return self; } - (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion { [[UIDevice currentDevice] setValue:@(self.originDeviceOrientation) forKey:@\"orientation\"]; [super dismissViewControllerAnimated:flag completion:completion]; } 例子(2).再来一个常用的，一个只支持Portrait的界面A push 一个支持三个方向(UIInterfaceOrientationMaskAllButUpsideDown)的界面B 要实现这个能力除了在A、B控制器里面分别实现上面写的函数外还需要转发转屏控制，因为window只询问到UINavigationController或UITabBarController，我们这里需要对UINavigationController的消息做转发，代码如下 @interface UINavigationController(Autorotate) @end @implementation UINavigationController(Autorotate) - (BOOL)shouldAutorotate { return self.viewControllers.lastObject.shouldAutorotate; } - (UIInterfaceOrientationMask)supportedInterfaceOrientations { return self.viewControllers.lastObject.supportedInterfaceOrientations; } - (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation { return self.viewControllers.lastObject.preferredInterfaceOrientationForPresentation; } @end 但是这样会出现一个bug，如果B处于横屏状态pop，然后再次push到B在pop，动画就会异常。类似下面这样的异常动画 查了半天没找到原因，然后发现手Q没这个问题，于是查看手Q代码发现手Q里面没有实现shouldAutorotate这个函数，其实supportedInterfaceOrientations这一个函数就完全可以搞定屏幕方向了，不知道Apple的工程师为什么设计两个接口来控制屏幕方向。这里把shouldAutorotate函数干掉就没问题了。 我们项目里面就有一个(2)这样的使用场景，前前后后遇踩了好多坑，总感觉这种使用方式有问题。最近思考了下，并把Apple本家的app都下载下来使用了下，没有看到(2)这种使用方式，而且系统API询问转屏只询问到UINavigationController说明Apple的API设计里面可能都没有考虑(2)这种使用场景。最后总结了下转屏的几个注意事项，欢迎大家批评指正。 1.全局都不用写shouldAutorotate，只写supportedInterfaceOrientations就够了。 2.不要像例子(2)里面一样去分发UINavigationController或UITabBarController的转屏控制函数，如果做了就要做好踩坑的准备，实在产品需求没办法可以考虑用present并定制一个跟push一样的transition动画。 3.支持不同方向的界面要像例子(1)这样用present，因为官方文档里面都是说的这样使用。 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/iOS转屏的坑和一些使用技巧.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/iOS/iOS转屏的坑和一些使用技巧.html\"});gitalk.render(\"gitalk-container\"); "},"其他/":{"url":"其他/","title":"其他","keywords":"","body":"其他 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/其他/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/其他/README.html\"});gitalk.render(\"gitalk-container\"); "},"其他/相似图片检测.html":{"url":"其他/相似图片检测.html","title":"相似图片检测","keywords":"","body":"相似图片检测 一、传统哈希算法 1.平均哈希算法（aHash） 此算法是基于比较灰度图每个像素与平均值来实现的，最适用于缩略图，放大图搜索 步骤： 1.缩放图片：为了保留结构去掉细节，去除大小、横纵比的差异，把图片统一缩放到8*8，共64个像素的图片 2.转化为灰度图：把缩放后的图片转化为256阶的灰度图 附上几种常用的灰度图相关算法（R = red， G = green， B = blue） 1.浮点算法：Gray = R * 0.3 + G * 0.59 + B * 0.11 2.整数方法：Gray = (R * 30 + G * 59 + B * 11) / 100 3.移位方法：Gray = (R * 76 + G * 151 + B * 28) >> 8 4.平均值法：Gray = (R + G + B) / 3 5.仅取绿色：Gray = G 3.计算平均值： 计算进行灰度处理后图片的所有像素点的平均值 4.比较像素灰度值：遍历灰度图片每一个像素，如果大于平均值记录为1，否则为0 5.得到信息指纹：组合64个bit位，顺序随意保持一致性即可 此算法可参考开源项目下载地址： http://download.csdn.net/detail/nash_/5093143 2.感知哈希算法（pHash） 平均哈希算法过于严格，不够精确，更适合搜索缩略图，为了获得更精确的结果可以选择感知哈希算法，它采用的是DCT（离散余弦变换）来降低频率的方法 步骤： 1.缩小图片：32 * 32是一个较好的大小，这样方便DCT计算 2.转化为灰度图：把缩放后的图片转化为256阶的灰度图。（具体算法见平均哈希算法步骤） 3.计算DCT:DCT把图片分离成分率的集合 4.缩小DCT：DCT是32*32，保留左上角的8*8，这些代表的图片的最低频率 5.计算平均值：计算缩小DCT后的所有像素点的平均值 6.进一步减小DCT：大于平均值记录为1，反之记录为0 7.得到信息指纹：组合64个信息位，顺序随意保持一致性即可 此算法可参考开源项目pHash，下载地址： http://www.phash.org/download/ 3.差异哈希算法（dHash） 相比pHash，dHash的速度要快的多，相比aHash，dHash在效率几乎相同的情况下的效果要更好，它是基于渐变实现的 步骤： 1.缩小图片：收缩到9*8的大小，以便它有72的像素点 2.转化为灰度图：把缩放后的图片转化为256阶的灰度图。（具体算法见平均哈希算法步骤） 3.计算差异值：dHash算法工作在相邻像素之间，这样每行9个像素之间产生了8个不同的差异，一共8行，则产生了64个差异值 4.获得指纹：如果左边的像素比右边的更亮，则记录为1，否则为0 流程如下：原始图像->压缩->灰度处理->计算hash值->汉明距离 这里着重介绍最后两步 对比指纹：根据两幅图片的指纹（选用上面三种hash计算方法中的一种计算出的值），计算汉明距离（从一个指纹到另一个指纹需要变几次），汉明距离越大则说明图片越不一致，反之，汉明距离越小则说明图片越相似，当距离为0时，说明完全相同。（通常认为距离>10 就是两张完全不同的图片） 二、几种特征算法 1.SIFT特征 SIFT具有较好的尺度不变性，即使改变旋转角度或者拍摄角度，仍然能够得到较好的检测效果，主要用来查找关键信息比如图片搜索。而且现在因为专利问题比较麻烦。 SIFT算法实现物体识别主要有三大工序，1、提取关键点；2、对关键点附加详细的信息（局部特征）也就是所谓的描述器；3、通过两方特征点（附带上特征向量的关键点）的两两比较找出相互匹配的若干对特征点，也就建立了景物间的对应关系。 2.SURF特征 SURF（Speeded Up Robust Features）是对SIFT的改进版本，改进后的主要优点是速度更快，更适合做实时的特征检查。对于需要实时运算的场合，如基于特征点匹配的实时目标跟踪系统，每秒要处理8-24帧的图像，需要在毫秒级内完成特征点的搜索、特征矢量生成、特征矢量匹配、目标锁定等工作，这样SIFT算法就很难适应这种需求了。实验证明，SURF算法较SIFT在运算速度上要快3倍左右。 3.GIST特征 三、聚类算法 1.K-means聚类、聚类中心点作为特征向量、对比向量相近度 四、颜色直方图匹配 图像直方图是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素数。 直方图只能做相同图像相同事物的比较，在做相似性图像的比较时效果较差，很难直接用于工业上的图像的相似性检索等工作 五、卷积神经网络 计算量比较大 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/其他/相似图片检测.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/其他/相似图片检测.html\"});gitalk.render(\"gitalk-container\"); "},"其他/树形红点系统.html":{"url":"其他/树形红点系统.html","title":"树形红点系统","keywords":"","body":"树形红点系统 [TOC] 有些新消息是重要的，需要展示成数字；有些新消息不那么重要，需要展示成红点。比如，我收到了新评论，或收到了新的点赞，以数字表示比较合理；而对于一些系统发给我的系统消息，我希望它不会太干扰到我的视线，这时以比较轻的红点形式展示比较合理。 数字和红点是需要分级展示的。当有新消息到来时，用户可以从App首页（即第一级页面）出发，根据数字和红点提示，逐级深入到更深的页面，最终到达展示新消息的终端页面。 如果某一级的数字提示，在它更深一级的页面上包含多个数字提示，那么本级数字应该是更深一级页面的数字之和。 如果某一级的数字（红点）提示，在它更深一级的页面上既有数字也有红点，那么本级优先按数字展示；如果更深一级的页面上数字都被清掉了，只有红点了，那么本级才按照红点展示。 下面以微信的部分红点系统为例子 采用“.”作为树形数据的分段关键字，比如 我->钱包->银行卡 这个路径可以使用 me.wallet.card表示 我这个tabbarItem监听路径 \"me\" 钱包这个cell监听路径“me.wallet” 银行卡这个路径监听\"me.wallet.card\" 后台下发银行卡这里给一个红点 那么我们就设置一个红点路径“me.wallet.card”，这时候会自动递归通知其父节点“me.wallet”和父父节点\"me\" A->B: 吃饭了没？ # 可在文本中使用换行符\\n note right of B: B思考n秒\\n如何回答 B--A: 吃过了。你咧？ A->>B: 吃过了，吃过了！ 虚线框里面的叶子才是真实有数据的红点，其他节点只供监听 任何位置的红点都可以通过统计子树的所有叶子得到 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/其他/树形红点系统.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/其他/树形红点系统.html\"});gitalk.render(\"gitalk-container\"); "},"其他/ITMS-90171.html":{"url":"其他/ITMS-90171.html","title":"ITMS-90171","keywords":"","body":"最近Swift和Objective-c混编使用脚本打包提交App Store遇到报错 ITMS-90171:\"Invalid Bundle Structure - The binary file \"xxx.app/libswiftRemoteMirror.dylib\" is not permitted\" 不啰嗦 这里把解决问题放第一位，所以这里先贴打包脚本源码 TARGET=\"xxx\" #这里一般填你的工程名字 PROJECT_NAME=$TARGET PROJECT_FILE=$PROJECT_NAME.xcodeproj CONFIGURATION=Release BUILD_FOLDER=build/$CONFIGURATION-iphoneos RESULT_FOLDER=result echo \"clear folder\" rm -rf $BUILD_FOLDER mkdir -p $BUILD_FOLDER rm -rf $RESULT_FOLDER mkdir -p $RESULT_FOLDER echo clean... xcodebuild -project $PROJECT_FILE -scheme $PROJECT_NAME -configuration $CONFIGURATION clean echo begin xcodebuild... xcodebuild -project $PROJECT_FILE -scheme $PROJECT_NAME -configuration $CONFIGURATION -archivePath $BUILD_FOLDER/$PROJECT_NAME.xcarchive archive echo begin xcrun... xcrun xcodebuild -exportArchive -exportOptionsPlist build_config/archive_option.plist -archivePath $BUILD_FOLDER/$PROJECT_NAME.xcarchive -exportPath $RESULT_FOLDER echo $RESULT_FOLDER/$PROJECT_NAME.ipa 这里附上archive_option.plist文件内容 method app-store teamID xxx uploadSymbols xcrun命令参考 有闲情逸致的可以看看下面的解决过程 首先google之查到一些信息，libswiftRemoteMirror.dylib这货是Xcode挖的坑，Swift跟oc混编用Xcode8的.app打包就会自动给你放个libswiftRemoteMirror.dylib这货在包里面，然后你提交的时候它有告诉你不允许包里面有这货，这时候我就想骂人了，但是想了下英语除了会fuck就不会其它高雅一点的了，于是放弃骂人，还是继续埋头想办法吧...于是习惯性的在网上找到一篇文章,这文章里面主要说了三个方法，先列出来 1.通过Xcode的Archive方式打包。Archive打的包，就没有包含这个libswiftRemoteMirror.dylib文件。 2.手动删除.app中的libswiftRemoteMirror.dylib文件，然后进行.app打包。 3.在Xcode7中进行.app打包。在Xcode7和Xcode8中分别进行.app打包，发现Xcode7打包后没有libswiftRemoteMirror.dylib文件 由于本人比较懒，能用脚本解决的事绝对不用鼠标点第二下，所以所有方法都是用脚本实现的 首先，方法3直接排除，尼玛苹果Xcode向下兼容做得最扯蛋的，Xcode8开发的项目还拿Xcode7去运行简直嫌自己被坑得不够惨吧！ 然后看方法2感觉很简单的样子，于是在压缩成ipa的脚本前面加了这两行代码（删文件+重签） rm -rf $BUILD_DIR/$PROJECT.app/libswiftRemoteMirror.dylib codesign -f -s 'xxx xxx xx, Ltd (xxxx)' $BUILD_DIR/$PROJECT.app 搞定提交，以为完事可以回家打豆豆了，但是苹果君还想让我陪它玩玩，于是又跳出来个错误 ITMS-90166:'Missing Code Signing Entitlements.No entitlements found in boundle 'com.xxx.xxx'for executable 'xxx/xxx.app/xxx'.'，好吧，你是大爷，你说错咱改还不行吗。于是继续找google君找答案，找了几个类似的但是都跟我遇到的情况都不一样，而且项目急需上架，于是我准备先用前面提到的方法1：Archive打包，但是打包完成后提交还是遇到报这个错,到这里我有点懵逼了，这时候一个叫柠檬的同事说遇到过相同的情况，咨询之，对方说他们改了脚本用Archive打包就搞定了，一语惊醒梦中人(谢谢柠檬同学)，对啊哥怎么没想到可以改用脚本Archive打包呢这样又可以规避一些Xcode的bug，于是把脚本中的.app打包方式改成Archive打包后就提交成功了。详细脚本请看上面 2018.11.04 Copyright © 413132340@qq.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 07:25:40 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/其他/ITMS-90171.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"6034224e8c0cb7a36f78\",\"clientSecret\":\"8fdce528ac92141adc0d1fae998d2c080a5ea510\",\"repo\":\"saucym.github.io\",\"owner\":\"saucym\",\"admin\":[\"saucym\"],\"id\":\"/其他/ITMS-90171.html\"});gitalk.render(\"gitalk-container\"); "}}