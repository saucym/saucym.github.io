---
title: 一行代码的约束解决方案
categories: iOS
tages: [iOS,Xcode,NSLayoutConstraint,Layout]
---
众所周知Apple提供的约束接口非常不好用，我们开发的时候基本都是用的第三方开源约束组件(比如Masonry)，虽然iOS9开始Apple已经意识到了这一点做了相应的更新但是他们的接口还是使用比较不方便。当然swift最新的约束写法是要好很多基本赶上Masonry了，然而我们现在大多项目还是不能完全切使用swift，所以objc的约束我们还是要继续用，由于我比较懒，就算swift最新的约束写法也不能满足我，于是我就开始思考有什么办法可以让我们写约束的时候可以非常简单最好一行代码能解决呢。因为我们大多数App已经从iOS9开始支持了，于是我就基于iOS9的UIViewLayoutConstraintCreation封装了一套简单的约束解决方案，所有代码加起来不到200行，非常简单高效，实现日常编码中大多数约束都能通过一行代码实现。走过路过千万不要错过，200行代码你看了不吃亏看了不上当。

首先要一行代码解决那就需要用到可变参数函数并且按约定的顺序填参数实现约束，其次考虑好用我们做iOS开发的对UIEdgeInsets的top, left, bottom, right这个顺序已经非常熟悉了，然后我们再加上宽高，继续加上是否支持safeArea，再加上是否是相等(或者大于等于，或者小于等于)，最后再加上两个比较少用的centerX centerY，这样我们整个函数10个参数就写好了，类似这样- [UIView wykit_constraint:top, left, bottom, right, width, height, supportSafeArea, relation, centerX, centerY, nil];
当然大多数时候我们只使用前4-6个参数就可以了(记得nil结尾)
下面上实现代码
```Objective-C
//.h
@interface UIView (WYKit)

/**
使用可变参数做约束 参数必须严格按这个照顺序给(top left bottom right width height supportSafeArea relation centerX centerY)且必须以nil结尾 没有的用不支持的类型占位(比如NSNull或者@[])。
supportSafeArea NSNumber (是否支持safeArea，default NO)
relation NSNumber 指定是约束相等还是 default NSLayoutRelationEqual TODO:这个参数暂时未实现

@param top left bottom right width height 这几个参数支持的类型 UIView NSLayoutAnchor NSNumber
@return 返回约束聚合对象
*/
- (WYKitConstraints *)wykit_constraint:(id)top, ... NS_REQUIRES_NIL_TERMINATION;

@end

//.m
@implementation UIView (WYKit)

- (WYKitConstraints *)wykit_constraint:(id)top, ... NS_REQUIRES_NIL_TERMINATION {
id left = nil;
id bottom = nil;
id right = nil;
id width = nil;
id height = nil;
id centerX = nil;
id centerY = nil;
BOOL supportSafeArea = NO;
NSLayoutRelation relation = NSLayoutRelationEqual;
//1.取出参数
if (top) {
va_list args;// 定义一个指向个数可变的参数列表指针；
va_start(args, top);// 初始化变量刚定义的va_list变量，这个宏的第二个参数是第一个可变参数的前一个参数，是一个固定的参数
do{
left = va_arg(args, id);
if (!left) break;
bottom = va_arg(args, id);
if (!bottom) break;
right = va_arg(args, id);
if (!right) break;
width = va_arg(args, id);
if (!width) break;
height = va_arg(args, id);
if (!height) break;
id flagObj = va_arg(args, id);
if (!flagObj) break;
if ([flagObj isKindOfClass:NSNumber.class]) {
supportSafeArea = [flagObj boolValue];
}
id relationObj = va_arg(args, id);
if (!relationObj) break;
if ([relationObj isKindOfClass:NSNumber.class]) {
relation = [relationObj integerValue];
NSAssert((relation == 0 || relation == 1 || relation == -1), @"数据不合法 必须是 NSLayoutRelationEqual NSLayoutRelationGreaterThanOrEqual 或 NSLayoutRelationLessThanOrEqual");
}
centerX = va_arg(args, id);
if (!centerX) break;
centerY = va_arg(args, id);
if (!centerY) break;
} while(0);
va_end(args);// 清空参数列表，并置参数指针args无效
}

//2.根据参数设置约束
self.translatesAutoresizingMaskIntoConstraints = NO;
UILayoutGuide *(^wykit_getGuide)(UIView *view) = ^(UIView *view) {
if (@available(iOS 11.0, *)) {
if (supportSafeArea) block_return view.safeAreaLayoutGuide;
}

block_return (UILayoutGuide *)view;
};

UILayoutGuide *guide = wykit_getGuide(self.superview);
NSLayoutConstraint *layout = nil;
WYKitConstraints *constraints = [WYKitConstraints new];
constraints.supportSafeArea = supportSafeArea;
constraints.relation = relation;

#define wykit_layout_item(x, r) \
if ([x isKindOfClass:UIView.class] || [x isKindOfClass:NSNumber.class] || [x isKindOfClass:NSLayoutAnchor.class]) {\
NSLayoutAnchor *xAnchor = [self x##Anchor];\
NSLayoutAnchor *anchor = ([xAnchor isKindOfClass:NSLayoutDimension.class]) ? nil : [guide x##Anchor];\
CGFloat constant = 0;\
if ([x isKindOfClass:UIView.class]) {\
anchor = [wykit_getGuide(x) x##Anchor];\
} else if ([x isKindOfClass:NSNumber.class]) {\
constant = [x floatValue];\
} else if ([x isKindOfClass:NSLayoutAnchor.class]) {\
anchor = x;\
}\
\
if ([xAnchor isKindOfClass:NSLayoutDimension.class]) {\
if ([anchor isKindOfClass:NSLayoutDimension.class]) {\
layout = [(NSLayoutDimension *)xAnchor r##Anchor:(NSLayoutDimension *)anchor constant:constant];\
} else {\
layout = [(NSLayoutDimension *)xAnchor r##Constant:constant];\
}\
} else {\
layout = [xAnchor r##Anchor:anchor constant:constant];\
}\
layout.active = YES;\
[constraints wykit_set##x:layout];\
}

#define wykit_layout_all(r) \
wykit_layout_item(top, r);\
wykit_layout_item(left, r);\
wykit_layout_item(bottom, r);\
wykit_layout_item(right, r);\
wykit_layout_item(width, r);\
wykit_layout_item(height, r);\
wykit_layout_item(centerX, r);\
wykit_layout_item(centerY, r);\

if (relation == NSLayoutRelationGreaterThanOrEqual) {
wykit_layout_all(constraintGreaterThanOrEqualTo);
} else if (relation == NSLayoutRelationLessThanOrEqual) {
wykit_layout_all(constraintLessThanOrEqualTo);
} else {
wykit_layout_all(constraintEqualTo);
}

return constraints;
}

@end
```

这里定义一个对象来保证扩展性，当然你也可以不要这个对象
```Objective-C
//.h
@interface WYKitConstraints : NSObject

@property (nonatomic, readonly) NSLayoutConstraint *top;
@property (nonatomic, readonly) NSLayoutConstraint *left;
@property (nonatomic, readonly) NSLayoutConstraint *bottom;
@property (nonatomic, readonly) NSLayoutConstraint *right;
@property (nonatomic, readonly) NSLayoutConstraint *width;
@property (nonatomic, readonly) NSLayoutConstraint *height;
@property (nonatomic, readonly) NSLayoutConstraint *centerX;
@property (nonatomic, readonly) NSLayoutConstraint *centerY;

@property (nonatomic, readonly) BOOL supportSafeArea; /**< 是否支持safeArea */
@property (nonatomic, readonly) NSLayoutRelation relation;/**< default NSLayoutRelationEqual */

- (void)config:(void (^)(WYKitConstraints *make))block; /**< 设置好约束后可以定制一些偏移值 */

@end

//.m
@interface WYKitConstraints ()
@property (nonatomic, assign) BOOL supportSafeArea;
@property (nonatomic, assign) NSLayoutRelation relation;
@end

@implementation WYKitConstraints : NSObject

- (void)wykit_settop:(NSLayoutConstraint *)top {
    _top = top;
}

- (void)wykit_setleft:(NSLayoutConstraint *)left {
    _left = left;
}

- (void)wykit_setbottom:(NSLayoutConstraint *)bottom {
    _bottom = bottom;
}

- (void)wykit_setright:(NSLayoutConstraint *)right {
    _right = right;
}

- (void)wykit_setwidth:(NSLayoutConstraint *)width {
    _width = width;
}

- (void)wykit_setheight:(NSLayoutConstraint *)height {
    _height = height;
}

- (void)wykit_setcenterX:(NSLayoutConstraint *)centerX {
    _centerX = centerX;
}

- (void)wykit_setcenterY:(NSLayoutConstraint *)centerY {
    _centerY = centerY;
}

- (void)config:(void (^)(WYKitConstraints *make))block {
    if (block) block(self);
}

@end
```

下面给几个实际项目中的使用例子
```Objective-C
//一个view布局参考父视图 离顶部5 左边5 宽180 高50并且后续可能会调整 可以用下面的一行代码简单实现
_segHeightLayout = [sView wykit_constraint:@5, @5, @0, @[], @180, @50, nil].height;

//还有很多实际使用列子，通过下面这些约束就实现了一个iOS11的大标题导航栏并且加搜索的约束了 效果下面会给出gif
[self wykit_constraint:@0, @0, @[], @0, @[], @[], nil];
_segHeightLayout = [sView wykit_constraint:@[], @5, @0, @[], @180, @(kCPASegHeight), nil].height;
_searchHeightLayout = [searchBar wykit_constraint:@[], @10, sView.topAnchor, @(-10), @[], @(kCPASearchHeight), nil].height;
_largeTitleHeightLayout = [largeView wykit_constraint:@[], @15, searchBar.topAnchor, @(-15), @[], @(kCPALargeHeight), nil].height;
[tLabel wykit_constraint:@[], @0, @(-5), @0, nil];
_titleHeightLayout = [navBar wykit_constraint:@0, @0, rView.topAnchor, @0, @[], @(kCPATitleHeight), @(YES), nil].height;
```

 以上就是全部实现，欢迎交流讨论
